#+TITLE: Dynamic Programming and recursion
#+SUBTITLE: Software Engineering Topics
#+INCLUDE: "../navbar.html" export html
#+OPTIONS: toc:nil
#+OPTIONS: num:nil
#+HEADER: :results output silent :headers '("\\usepackage{tikz}")
#+HEADER: :results output silent :headers '("\\usepackage{pgfplots}")

* GeeksForGeeks: [[https://practice.geeksforgeeks.org/problems/0-1-knapsack-problem0945/1][0 - 1 Knapsack Problem]]
#+begin_src java
class Solution 
{ 
    //Function to return max value that can be put in knapsack of capacity W.
    static int knapSack(int W, int wt[], int val[], int n) 
    { 
        // dp[i][j] is the value obtained by the sum of weights i and by looking until index j of wt[] and val[]
        int[][] dp = new int[W+1][n];
        for (int i = 0; i <= W; i++){
            for (int j = 0; j < n; j++){
                // if the considered capacity i is bigger than the j-th weight
                if (i >= wt[j]) // the first element can be either zero or the jth value.
                    if (j == 0) dp[i][0] = val[j];
                    else dp[i][j] = Math.max(dp[i][j-1], dp[i-wt[j]][j-1] + val[j]);
                else if (j > 0) // just take previous element
                    dp[i][j] = dp[i][j-1];
            }
        }
    return dp[W][n-1];
    }
}
#+end_src

There are two important information that must be tracked in this problem:

  1. the total sum of weights for a particular selection
  2. the picked items

This solution uses $dp[W+1][n]$ to track the total sum of weights of the picked
items in the rows, and the limit of the index considered for the items in the
columns. We already know that the space and time complexity of this problem is
$O(WN)$. The advantage of using the columns as the limit of indexes considered
is that we can always asure that an item is not being picked twice, i.e. when
iterating at the jth column we can be sure that this number was not picked before
for all solutions $dp[i][k]$ for $k < j$.

Subproblems are used to build up bigger problems, as we define:
$$d[i][j]=Math.max(dp[i][j-1],dp[i-wt[j]][j-1]+val[j])$$

that means that we will loop for every item, and select the max value obtained by
either picking the last value $dp[i][j-1]$, i.e. the value considering the from
the first to the last item, or $dp[i-wt[j]][j-1] + val[j]$, i.e. by picking the
jth item. As the jth item has weight $wt[j]$ then the total weight before was
$i-wt[j]$.

* LeetCode: [[https://leetcode.com/problems/can-i-win/][Can I Win - 464]]
   
 #+begin_src java
   class Solution {
       Map<List<Boolean>, Boolean> memory;
       List<Boolean> choosedNumbers;

       public boolean canIWin(int maxChoosableInteger, int desiredTotal) {
	   if (desiredTotal == 0) return true;
	   //numbers don't add up to dT
	   if ((1+maxChoosableInteger)*maxChoosableInteger/2<desiredTotal) return false;

	   // initialize memory and initial state
	   memory = new HashMap<>();
	   Boolean[] array = new Boolean[maxChoosableInteger];
	   Arrays.fill(array, false);
	   choosedNumbers = Arrays.asList(array);
	   return recCanIWin(desiredTotal, choosedNumbers);
       }
       // returning true means that the current player won and false otherwise
       public Boolean recCanIWin(int desiredTotal, List<Boolean> state){
	   if (!memory.containsKey(state)){
	       // the other player won!
	       if (desiredTotal <= 0) return false;
	       // if dT > 0 the current player picks an unchoosed number
	       for (int i = 0; i< state.size(); i++){
		   if (!state.get(i)){
		       state.set(i, true);
		       // if it's not the case that the next player wins with this choice
		       if (!recCanIWin(desiredTotal - (i+1), state)){
			   state.set(i, false);
			   memory.put(new ArrayList<Boolean>(state), true);
			   return true;
		       }
		       state.set(i, false);
		   }
	       }
	       memory.put(new ArrayList<Boolean>(state), false);
	   }
	   return memory.get(state);
       }
   }
#+end_src
* LeetCode: [[https://leetcode.com/problems/super-egg-drop/][Super Egg Drop - 887]]
#+begin_src java
class Solution {
    public int superEggDrop(int k, int n) {        
        int[]dp=new int[k+1];
        int m=0; 
        
        while(dp[k]<n){
            m++;
            for(int i=k; i>0; i--){
                dp[i]+=dp[i-1]+1;
            }
        }
        return m;
    }
}
#+end_src
The variable $dp[i]$ in this solution refers to the number of floors which f can
be defined with certainty with $i$ eggs. At each iteration of the while loop
there is one additional move available compared to the last iteration, and the
question becomes how can one fill $dp$ taking into consideration previous values.
Imagine we found ourselves in the middle the building, if we drop the egg in that
floor and it breaks we can conclude that f is in lower floors, and we have one
less move, that is exactly $dp[i-1]$ from our previous while loop iteration. If
the egg doesn't break, then we conclude f is in upper floors and we can still
reach $dp[i]$ of them, hence:
\[dp[i] = dp[i] + dp[i-1] + 1\]

Notice the $+1$ accounts for the floor we are in, and that the first move drops
the egg in a new floor.
