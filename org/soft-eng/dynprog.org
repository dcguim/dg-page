#+TITLE: Dynamic Programming and recursion
#+SUBTITLE: Software Engineering Topics
#+INCLUDE: "../navbar.html" export html
#+OPTIONS: toc:nil
#+OPTIONS: num:nil
#+HEADER: :results output silent :headers '("\\usepackage{tikz}")
#+HEADER: :results output silent :headers '("\\usepackage{pgfplots}")

* GeeksForGeeks: [[https://practice.geeksforgeeks.org/problems/0-1-knapsack-problem0945/1][0 - 1 Knapsack Problem]]
#+begin_src java
class Solution 
{ 
    //Function to return max value that can be put in knapsack of capacity W.
    static int knapSack(int W, int wt[], int val[], int n) 
    { 
        // dp[i][j] is the value obtained by the sum of weights i and by looking until index j of wt[] and val[]
        int[][] dp = new int[W+1][n];
        for (int i = 0; i <= W; i++){
            for (int j = 0; j < n; j++){
                // if the considered capacity i is bigger than the j-th weight
                if (i >= wt[j]) // the first element can be either zero or the jth value.
                    if (j == 0) dp[i][0] = val[j];
                    else dp[i][j] = Math.max(dp[i][j-1], dp[i-wt[j]][j-1] + val[j]);
                else if (j > 0) // just take previous element
                    dp[i][j] = dp[i][j-1];
            }
        }
    return dp[W][n-1];
    }
}
#+end_src

There are two important information that must be tracked in this problem:

  1. the total sum of weights for a particular selection
  2. the picked items

This solution uses $dp[W+1][n]$ to track the total sum of weights of the picked
items in the rows, and the limit of the index considered for the items in the
columns. We already know that the space and time complexity of this problem is
$O(WN)$. The advantage of using the columns as the limit of indexes considered
is that we can always asure that an item is not being picked twice, i.e. when
iterating at the jth column we can be sure that this number was not picked before
for all solutions $dp[i][k]$ for $k < j$.

Subproblems are used to build up bigger problems, as we define:
$$d[i][j]=Math.max(dp[i][j-1],dp[i-wt[j]][j-1]+val[j])$$

that means that we will loop for every item, and select the max value obtained by
either picking the last value $dp[i][j-1]$, i.e. the value considering the from
the first to the last item, or $dp[i-wt[j]][j-1] + val[j]$, i.e. by picking the
jth item. As the jth item has weight $wt[j]$ then the total weight before was
$i-wt[j]$.

* LeetCode: [[https://leetcode.com/problems/can-i-win/][Can I Win - 464]]
   
 #+begin_src java
   class Solution {
       Map<List<Boolean>, Boolean> memory;
       List<Boolean> choosedNumbers;

       public boolean canIWin(int maxChoosableInteger, int desiredTotal) {
	   if (desiredTotal == 0) return true;
	   //numbers don't add up to dT
	   if ((1+maxChoosableInteger)*maxChoosableInteger/2<desiredTotal) return false;

	   // initialize memory and initial state
	   memory = new HashMap<>();
	   Boolean[] array = new Boolean[maxChoosableInteger];
	   Arrays.fill(array, false);
	   choosedNumbers = Arrays.asList(array);
	   return recCanIWin(desiredTotal, choosedNumbers);
       }
       // returning true means that the current player won and false otherwise
       public Boolean recCanIWin(int desiredTotal, List<Boolean> state){
	   if (!memory.containsKey(state)){
	       // the other player won!
	       if (desiredTotal <= 0) return false;
	       // if dT > 0 the current player picks an unchoosed number
	       for (int i = 0; i< state.size(); i++){
		   if (!state.get(i)){
		       state.set(i, true);
		       // if it's not the case that the next player wins with this choice
		       if (!recCanIWin(desiredTotal - (i+1), state)){
			   state.set(i, false);
			   memory.put(new ArrayList<Boolean>(state), true);
			   return true;
		       }
		       state.set(i, false);
		   }
	       }
	       memory.put(new ArrayList<Boolean>(state), false);
	   }
	   return memory.get(state);
       }
   }
#+end_src
One way of seeing this problem is as a recursive problem which, at some point in
time, the current player attempts all the unpicked numbers, and we store this
choice in a state and pass it to the next iteration along with the rest of the
sum, until finally the sum is smaller than 0. As the state is just a sequence
of subsequent numbers which were or not picked, we can represent as a boolean
array. Notice also the symmetry in this problem, assume the `desiredTotal = 20`
first player could pick 1, the second 5, and then 10, or the first player could
pick 10, the second 1, and then first 5, regardless of who choose which number
all we care about is that the `desiredTotal = 4` and the picked numbers were 1, 5
and 10, so there is no need of tracking each players choice, and therefore, the
solutions are overlapping, hence, we also need a memory to map states to boolean.

If we negate the value of the next recurrent call we are somewhat programming the
idea that if in the next call it returns true, than the previous player lost.
In the worst case this solution will generate all the $2^{maxChoosableInteger}$
combinations, therefore $O(2^{n})$

* LeetCode: [[https://leetcode.com/problems/super-egg-drop/][Super Egg Drop - 887]]
#+begin_src java
class Solution {
    public int superEggDrop(int k, int n) {        
        int[]dp=new int[k+1];
        int m=0; 
        
        while(dp[k]<n){
            m++;
            for(int i=k; i>0; i--){
                dp[i]+=dp[i-1]+1;
            }
        }
        return m;
    }
}
#+end_src
The variable $dp[i]$ in this solution refers to the number of floors which f can
be defined with certainty with $i$ eggs. At each iteration of the while loop
there is one additional move available compared to the last iteration, and the
question becomes how can one fill $dp$ taking into consideration previous values.
Imagine we found ourselves in the middle the building, if we drop the egg in that
floor and it breaks we can conclude that f is in lower floors, and we have one
less move, that is exactly $dp[i-1]$ from our previous while loop iteration. If
the egg doesn't break, then we conclude f is in upper floors and we can still
reach $dp[i]$ of them, hence:
\[dp[i] = dp[i] + dp[i-1] + 1\]

Notice the $+1$ accounts for the floor we are in, and that the first move drops
the egg in a new floor. It would be nice to build a sense of how fast is $dp[k]$
reaching $n$ so we could understant how fast this program runs. Let's assume for
simplicity that $n=9$ and $k=2$:
|-----+-------+-------|
|   m | dp[2] | dp[1] |
|-----+-------+-------|
|   1 |     1 |     1 |
|   2 |     3 |     2 |
|   3 |     6 |     3 |
|   4 |    10 |     4 |
| ... |   ... |   ... |
|-----+-------+-------|

Notice that while $dp[1]$ approaches $n$ linearly, $dp[2]$ seems to be a some
strange series which is neither geometric nor arithmetic but as we already
uncovered in the algorithm it is exactly $dp[1]$ so we have an arithmetic
progression which it's ratio behaves as an arithmetic progression of ratio 1.
|------+-------|
| term | incr. |
|------+-------|
|    1 |     - |
|    3 |     2 |
|    6 |     3 |
|   10 |     4 |
|------+-------|

So how would we describe the $n$ -th dp[2]?

\[ dp[2]_n = 1 + 2 + 3 + ... + n = \dfrac{n(n+1)}{2}\]


Hence, $dp[2]$ advances quadratically towards $n$, therefore $O(log(n))$. But we
are not interested in having the constraint of $k=2$. So would removing this
constraint lead us to a different uper bound?

Let's look into what would change had $k=3$:
|-----+-------+-------+-------|
|   m | dp[3] | dp[2] | dp[1] |
|-----+-------+-------+-------|
|   1 |     1 |     1 |     1 |
|   2 |     3 |     3 |     2 |
|   3 |     7 |     6 |     3 |
|   4 |    14 |    10 |     4 |
| ... |   ... |   ... |   ... |
|-----+-------+-------+-------|

The increment now changed! Now the increment of the increment is linear!
|------+-------+-------|
| term | incr. | incr. |
|------+-------+-------|
|    1 |     - |     - |
|    3 |     2 |     - |
|    7 |     4 |     2 |
|   14 |     7 |     3 |
|   25 |    11 |     4 |
|------+-------+-------|

That means that the middle column is concretely $dp[2]$ if we had started from
2 as opposed to one. And hence $dp[3]_n$ would be roughly:

\[dp[3]_n = \sum \dfrac{n(n+1)}{2} = \dfrac{1}{2}\sum n^2 + \dfrac{1}{2}\sum n\]

To solve $\dfrac{1}{2}\sum n^2$ we need to draw some insight from the Faulhaber's
formula, luckily, I have written another [[file:faulhaberseries.html][post]] about it.

The answer is that we always a polynomial with the order of the sum plus one that
means in the order of $n^3$. As we will always add a new summation for each higher
value of $k$ we are always approaching $n$ with $n^k$ which will change the
base of the logarithm. But we don't care about the base as it's always just a
constant away, so we will stay with $log(n)$. However, for each higher value of
$k$ we will have a higher computation time for the inner for loop, therefore
the final upper bound is $O(klog(n))$
