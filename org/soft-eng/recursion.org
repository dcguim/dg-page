#+TITLE: knowledge repo
#+SUBTITLE: Software Engineering Topics
#+AUTHOR: Daniel Guimaraes
#+OPTIONS: toc:nil
#+OPTIONS: num:nil
#+HEADER: :results output silent :headers '("\\usepackage{tikz}")
#+HEADER: :results output silent :headers '("\\usepackage{pgfplots}")
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="../code.css"/>
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="../style.css"/>

#+begin_export html
<ul class='navbar'> 
  <li><a href="/">Home</a></li>
  <li><a href="/static/data-eng/index.html">Data Engineering</a></li>
  <li><a href="/static/soft-eng/index.html">Software Engineering</a></li>
</ul>
#+end_export


* Recursion
LeetCode: Can I Win [[https://leetcode.com/problems/can-i-win/][464]].
   
#+begin_src java
class Solution {
    Map<List<Boolean>, Boolean> memory;
    List<Boolean> choosedNumbers;
    
    public boolean canIWin(int maxChoosableInteger, int desiredTotal) {
        if (desiredTotal == 0) return true;        
        if ((1+maxChoosableInteger)*maxChoosableInteger/2<desiredTotal) return false; //numbers don't add up to dT
            
        // initialize memory and initial state
        memory = new HashMap<>();
        Boolean[] array = new Boolean[maxChoosableInteger];
        Arrays.fill(array, false);
        choosedNumbers = Arrays.asList(array);
        return recCanIWin(desiredTotal, choosedNumbers);
    }
    // returning true means that the current player won and false otherwise
    public Boolean recCanIWin(int desiredTotal, List<Boolean> state){
        if (!memory.containsKey(state)){
            // the other player won!
            if (desiredTotal <= 0) return false;
            // if dT > 0 the current player picks an unchoosed number
            for (int i = 0; i< state.size(); i++){
                if (!state.get(i)){
                    state.set(i, true);
                    // if it's not the case that the next player wins with this choice
                    if (!recCanIWin(desiredTotal - (i+1), state)){
                        state.set(i, false);
                        memory.put(new ArrayList<Boolean>(state), true);
                        return true;
                    }
                    state.set(i, false);
                }
            }
            memory.put(new ArrayList<Boolean>(state), false);
        }
        return memory.get(state);
    }
}
#+end_src
  



